<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Andrews hard work</title>
	<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
	<link rel="stylesheet" href="../entry.css">
</head>

<body>
	<nav class="navbar">
		<div class="back">
			<a href="../game_main.html"><i class="material-icons"
					style="font-size: 60px; color: rgb(219, 136, 111);">keyboard_arrow_left</i></a>
		</div>
		<h1>Game Development</h1>
	</nav>
	<nav class="page-body">
		<div class="header">
			<h2>Entry 15&nbsp;</h2>
			<div class="date">June 3, 2024</div>
		</div>
		<div class="body" id="overview">
			<p>
				this week, I continued the concept of my game. Within this week, I added the planet sprite, the main
				objective for the game, with a randomised planet image and random position.
			</p>
		</div>
		<div class="body" id="evidence">
			<p>The changed code for my Pygame game is in this <a target="_blank"
					href="https://github.com/expertkaos/GameDev11/compare/Entry_14...Entry_15">Git Hub Repository.</a>
			</p>
		</div>
		<div class="body" id="content">
			<p>Before adding any new code, I took the time to tidy up what I already had. I reorganised my classes to
				make them clearer and moved the background logic into its own Python file and class. This made my code
				easier to read and understand for me and anyone else looking at it.</p>
			<p>The core focus of my game revolves around the planet component, necessitating the development of their
				logic. My sister contributed by drawing numerous planets, which I then transformed into a sprite sheet.
				This allowed me to efficiently manage their appearances by creating a subsurface for each planet's
				image. Given that all planets shared identical dimensions, I could segment the sprite sheet by dividing
				the total width by the number of planet images, thus facilitating the cropping process.</p>
			<p>To render multiple planets, I created a tuple that holds the x and y coordinates and the corresponding
				image values of each planet. Currently, these coordinates are randomised, which presents a couple of
				challenges: overlapping planets and the potential for players to exhaust the supply of planets if they
				venture too far. To address these issues, I've brainstormed two potential solutions: one involves
				creating a system capable of generating an infinite array of planets, rendering only those within
				proximity to the player; the other entails using a vast sheet peppered with planets, designed to wrap
				the background if the player strays too far. I'm in the process of deciding which approach to implement.
				Once a planet image is set, the code calculates the sprite sheet's total width, divides it by the number
				of planets, and randomly selects a crop size for each tuple.</p>
		</div>
		<div class="body" id="review">
			<h3>What challenges did I face when implementing the planet sprites, and how did I overcome them?</h3>
			<p>While working on the Planet Sprite for my game, I encountered a coding issue that was new to me. The
				error message "ValueError: subsurface rectangle outside surface area" popped up, indicating a problem I
				hadn't faced before. It was an error stemming from a simple miscalculation. The issue was that my code
				attempted to crop an area outside the bounds of the sprite sheet, which caused the subsurface function
				to fail.</p>
			<h3>How should I balance game performance and player interest when choosing a planet generation method?</h3>
			<p>In my game development, generating planets is a critical task that requires a method ensuring smooth
				gameplay and sustained player engagement. The challenge lies in selecting a system that doesn’t
				compromise the game’s performance or introduce glitches. My goal is to maintain an exciting and fun
				environment that motivates players to continue their exploration and discovery of new planets. The
				balance between technical efficiency and gameplay quality is paramount.</p>
			<p>Considering the ‘sheet method’ for planet generation, I recognise a potential issue: it might eventually
				make mining planets too easy and less challenging for players. However, this method has the advantage of
				being simpler to implement since it builds on existing logic and requires only minor adjustments.
				Conversely, the alternative method involves developing a new system for dynamically loading and
				unloading planets to create an endless universe. This would demand a more complex solution but could
				offer an engaging experience by providing infinite planets to explore.</p>
		</div>
	</nav>
</body>

</html>